#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "ao_common.glsl"

struct GlobalUniforms {
    mat4 view_inverse;
    mat4 proj_inverse;
};

layout(location = 0) rayPayloadEXT MainPassPayload main_payload;
layout(location = 1) rayPayloadEXT AOPayload ao_payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT scene_as;
layout(set = 0, binding = 1, rgba8) uniform image2D image;
layout(set = 1, binding = 0) uniform _GlobalUniforms { GlobalUniforms globals; };

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

vec3 randomSpherePoint(vec2 rand) {
    float ang1 = (rand.x + 1.0) * PI;
    float u = rand.y;
    float u2 = u * u;
    float sqrt1MinusU2 = sqrt(1.0 - u2);
    float x = sqrt1MinusU2 * cos(ang1);
    float y = sqrt1MinusU2 * sin(ang1);
    float z = u;
    return vec3(x, y, z);
}

vec3 randomHemispherePoint(vec2 rand, vec3 n) {
    vec3 v = randomSpherePoint(rand);
    return v * sign(dot(v, n));
}

vec3 rotate_vector(vec3 from, vec3 to) {
    float theta = dot(from, to) * 2 * PI;

    mat3 g = mat3(
        cos(theta), -sin(theta), 0.0,
        sin(theta), cos(theta), 0.0,
        0.0, 0.0, 0.0
    );

    return vec3(0.0);
}

vec2 Hammersley(float i, float numSamples) {
    uint b = uint(i);

    b = (b << 16u) | (b >> 16u);
    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);
    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);
    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);
    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);

    float radicalInverseVDC = float(b) * 2.3283064365386963e-10;

    return vec2((i / numSamples), radicalInverseVDC);
}

vec3 SampleHemisphere_Uniform(float i, float numSamples) {
    // Returns a 3D sample vector orientated around (0.0, 1.0, 0.0)
    // For practical use, must rotate with a rotation matrix (or whatever
    // your preferred approach is) for use with normals, etc.

	vec2 xi = Hammersley(i, numSamples);

    float phi = xi.y * 2.0 * PI;
    float cosTheta = 1.0 - xi.x;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    return vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);
}

void main() {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);

    const vec2 d = in_uv * 2.0 - 1.0;

    vec3 world_origin = (globals.view_inverse * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    const vec3 target = (globals.proj_inverse * vec4(d.x, -d.y, 1.0, 1.0)).xyz;
    const vec3 world_direction = (globals.view_inverse * vec4(normalize(target), 0.0)).xyz;

    const uint cull_mask = 0xFFu;

    vec3 origin = world_origin;
    vec3 direction = world_direction;

    {
        const uint ray_flags = gl_RayFlagsOpaqueEXT;

        main_payload.color = vec3(0.0);
        main_payload.t = -1.0;

        traceRayEXT(scene_as, ray_flags, cull_mask, 0u, 0u, 0u, origin, 0.0001, direction, 1000.0, 0);
    }

    vec3 final_color = main_payload.color / 10.0;

    vec3 ao_color = vec3(0.0);

    if (main_payload.t > 0.0) {
        for (uint i = 0; i < AO_SPP; i++) {
            const uint ray_flags = gl_RayFlagsTerminateOnFirstHitEXT;
            ao_payload.t = 0.0;

            vec3 ao_sample_origin = origin + direction * main_payload.t;

	        vec3 b1 = normalize(direction - main_payload.normal * dot(direction, main_payload.normal));
	        vec3 b2 = cross(main_payload.normal, b1);
	        mat3 tbn = mat3(b1, b2, main_payload.normal);

            float random_x = random(in_uv);
            float random_y = random(1.0 - in_uv);

            vec3 ao_sample_direction = randomHemispherePoint(vec2(0.0, 0.0), main_payload.normal);

            traceRayEXT(scene_as, gl_RayFlagsOpaqueEXT, cull_mask, 1u, 0u, 0u, ao_sample_origin, FLT_MIN, ao_sample_direction, 1.0, 1);

            // ao_color += vec3(ao_payload.t);
            ao_color += main_payload.normal;
        }
    }

    // ao_color /= AO_SPP;

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(final_color + ao_color, 1.0));
}